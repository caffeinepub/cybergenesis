{
  "kind": "build_request",
  "title": "Fix CubeVisualisation.tsx black screen (buffer/layer sync) and replace MapView.tsx with Leaflet implementation",
  "priority": "high",
  "requirements": [
    {
      "id": "REQ-1",
      "text": "In CubeVisualisation.tsx, replace the existing useFrame callback inside SelectiveBloomEffect with the following exact implementation that properly swaps render buffers and resets camera layers:\n\n```ts\nuseFrame((state) => {\n  const { gl, camera } = state;\n  if (!bloomComposerRef.current || !finalComposerRef.current) return;\n\n  // STEP 1: Render Bloom (Only crystals/glow)\n  camera.layers.set(1);\n  bloomComposerRef.current.render();\n\n  // STEP 2: Link active bloom buffer to composite shader\n  const currentBloomTexture = bloomComposerRef.current.readBuffer.texture;\n  const compositePass = finalComposerRef.current.passes[1] as any;\n  if (compositePass?.uniforms?.bloomTexture) {\n    compositePass.uniforms.bloomTexture.value = currentBloomTexture;\n  }\n\n  // STEP 3: Render Final Scene (Background + Land + Glow)\n  gl.autoClear = true;\n  camera.layers.set(0); // Bring back BackgroundSphere\n  camera.layers.enable(1); // Keep Crystals/Glow\n  finalComposerRef.current.render();\n}, 1);\n```",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-5"
        ],
        "quotes": [
          "Replace the current useFrame in SelectiveBloomEffect with this. It ensures the background (Layer 0) returns and the bloom texture is always fresh.",
          "This is the fix for the black screen - getting the texture from 'readBuffer'"
        ]
      },
      "acceptanceCriteria": [
        "The bloom composer renders only layer 1 (crystals/glow) before the final composite",
        "bloomComposerRef.current.readBuffer.texture is assigned to compositePass.uniforms.bloomTexture.value each frame",
        "After bloom render, camera.layers is reset to 0 and layer 1 re-enabled so BackgroundSphere is visible in final pass",
        "gl.autoClear is set to true inside useFrame before finalComposer.render()"
      ]
    },
    {
      "id": "REQ-2",
      "text": "In CubeVisualisation.tsx, inside the onCreated callback of the Canvas (or equivalent renderer initialization block), set `gl.autoClear = false` so the WebGL renderer does not auto-clear and fight with the composer's manual clear in useFrame.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-5"
        ],
        "quotes": [
          "Set: gl.autoClear = false; (Since we manually set it to true in the loop above)."
        ]
      },
      "acceptanceCriteria": [
        "gl.autoClear = false is present in the onCreated / renderer initialization block of the Canvas component",
        "No duplicate or conflicting autoClear assignments exist outside of the useFrame loop"
      ]
    },
    {
      "id": "REQ-3",
      "text": "Completely replace the entire contents of frontend/src/components/MapView.tsx with the following code verbatim (preserving all comments, styles, and logic):\n\n```tsx\nimport React, { useEffect, useRef } from 'react';\n// Libraries loaded via CDN — using window.L\nimport { useActor } from '../hooks/useActor';\nimport { useQuery } from '@tanstack/react-query';\n\nconst MAP_SIZE = 2560;\nconst RAW_MAP_URL = 'https://raw.githubusercontent.com/dobr312/cyberland/main/CyberMap/IMG_0133.webp';\n\nconst MapView = ({ onClose }) => {\n  const mapContainerRef = useRef(null);\n  const mapRef = useRef(null);\n  const { actor } = useActor();\n\n  const { data: lands } = useQuery({\n    queryKey: ['landData'],\n    queryFn: () => actor?.getLandData(),\n    enabled: !!actor,\n  });\n\n  useEffect(() => {\n    if (!mapContainerRef.current || mapRef.current || !window.L) return;\n\n    const L = window.L;\n\n    const map = L.map(mapContainerRef.current, {\n      crs: L.CRS.Simple,\n      minZoom: -1,\n      maxZoom: 2,\n      zoomControl: false,\n      attributionControl: false,\n      inertia: true\n    });\n\n    mapRef.current = map;\n\n    const bounds = [[0, 0], [MAP_SIZE, MAP_SIZE]];\n    L.imageOverlay(RAW_MAP_URL, bounds).addTo(map);\n    map.fitBounds(bounds);\n    map.setMaxBounds(bounds);\n\n    if (lands) {\n      lands.forEach(land => {\n        const color = getBiomeColor(land.biome);\n        L.polyline([[1280, 1280], [land.y, land.x]], {\n          color: color,\n          weight: 2,\n          opacity: 0.8,\n          className: `neon-beam-${land.biome.toLowerCase()}`\n        }).addTo(map);\n      });\n    }\n\n    return () => {\n      map.remove();\n      mapRef.current = null;\n    };\n  }, [lands]);\n\n  const getBiomeColor = (biome) => {\n    const colors = {\n      'MYTHIC_VOID': '#9933FF',\n      'MYTHIC_AETHER': '#00FFFF',\n      'VOLCANIC_CRAG': '#ff3300',\n      'DESERT_DUNE': '#FF8800',\n      'FOREST_VALLEY': '#00ff41',\n      'SNOW_PEAK': '#ffffff',\n      'DEFAULT': '#00aaff'\n    };\n    return colors[biome] || colors.DEFAULT;\n  };\n\n  return (\n    <div style={containerStyle}>\n      <div ref={mapContainerRef} style={{ width: '100%', height: '100%', background: '#000' }} />\n      <button onClick={onClose} style={closeButtonStyle}>✕</button>\n      <style>{`\n        .leaflet-container { background: #000 !important; cursor: grab; }\n        .leaflet-container:active { cursor: grabbing; }\n        ${['MYTHIC_VOID', 'VOLCANIC_CRAG', 'DESERT_DUNE', 'MYTHIC_AETHER', 'FOREST_VALLEY'].map(b => `\n          .neon-beam-${b.toLowerCase()} {\n            filter: drop-shadow(0 0 6px ${getBiomeColor(b)});\n            stroke-linecap: round;\n            stroke-linejoin: round;\n          }\n        `).join('')}\n      `}</style>\n    </div>\n  );\n};\n\nconst containerStyle = {\n  position: 'fixed',\n  inset: 0,\n  zIndex: 9999,\n  background: '#000',\n  overflow: 'hidden'\n};\n\nconst closeButtonStyle = {\n  position: 'absolute',\n  top: '30px',\n  right: '30px',\n  zIndex: 10001,\n  padding: '12px 24px',\n  background: 'rgba(0,0,0,0.7)',\n  color: '#fff',\n  border: '1px solid rgba(255,255,255,0.2)',\n  borderRadius: '12px',\n  cursor: 'pointer',\n  fontSize: '18px',\n  backdropFilter: 'blur(10px)'\n};\n\nexport default MapView;\n```",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-5"
        ],
        "quotes": [
          "А ниже Mapview.tsx, его переписать нужно с нуля заменив на этот код"
        ]
      },
      "acceptanceCriteria": [
        "frontend/src/components/MapView.tsx contains exactly the provided code and nothing from the previous Maptalks-based implementation",
        "The map uses L.CRS.Simple (pixel-grid coordinate system) loaded from window.L (Leaflet CDN)",
        "The image overlay uses the URL https://raw.githubusercontent.com/dobr312/cyberland/main/CyberMap/IMG_0133.webp with bounds [[0,0],[2560,2560]]",
        "Land data is fetched via useQuery with queryKey ['landData'] and actor?.getLandData()",
        "Each land plot renders a polyline from center [1280,1280] to [land.y, land.x] with biome-appropriate neon color",
        "Neon beam CSS classes apply drop-shadow filter per biome",
        "Close button renders at top-right and calls onClose prop",
        "Map is properly removed and ref cleared on component unmount"
      ]
    }
  ],
  "constraints": [
    "Do not modify any backend Motoko files",
    "Do not alter any files listed in frontend.immutablePaths",
    "MapView.tsx must be a complete replacement — no code from the old Maptalks implementation should remain",
    "The useFrame replacement in CubeVisualisation.tsx must match the provided code exactly — do not refactor or optimize"
  ],
  "nonGoals": [
    "Adding Leaflet as an npm dependency — it is intentionally loaded via CDN (window.L)",
    "Changes to any other component or page beyond CubeVisualisation.tsx and MapView.tsx",
    "Backend changes of any kind",
    "Visual redesign or theme changes"
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  }
}